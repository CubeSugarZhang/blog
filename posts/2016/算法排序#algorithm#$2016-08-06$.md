> 循序渐进

### 选择排序
这是一种最简单的排序，它会遍历的找到集合中最小的元素，让它与第一个元素交换位置，接下来从剩下的元素中找到最小的，与集合中的第二个元素交换位置，如此往复，直到最后完成排序。

```javascript
const Selection = (coll) => {
  const len = coll.length
  for(var i = 0; i < len; i++) {
    var min = i
    for(var j = i+1; j < len; j++) {
      if(coll[j] < coll[min]) min = j
    }

    // 交换元素
    exchange(coll, i, min)
  }
}
```
这种排序的过程如下
```
const arr = [2, 4, 1, 3, 5]
Selection(arr)

i  min   0    1    2    3    4
         2,   4,   1,   3,   5
0   2    2,   4,   1,   3,   5
1   2    1,   4,   2,   3,   5
2   3    1,   2,   4,   3,   5
3   3    1,   2,   3,   4,   5
4   4    1,   2,   3,   4,   5
```
#### 总结：
选择排序的时间复杂度为O(N^2)。

长度为N的集合，选择排序总共会进行N次的交换，每一次交换都会有N-1-i的比较，因此总共会有(N-1)+(N-2)+...+(N-1-i)~N^2次的比较。

### 插入排序
跟我们打牌时整理牌的方式很像，将每一张牌插入到有序牌中的适当的位置。例如我习惯从左到右按照从小到大排序，我拿到牌后，会将手上的牌从左到右，将小的牌往前面插入。

```javascript
const Insertion = (coll) => {
  const len = coll.length
  for(var i = 1; i < len; i++) {
    var min = i
    for(var j = i; j > 0 && coll[j] < coll[j-1]; j--) {
      exchange(coll, j, j-1)
    }
  }
}
```
这种排序的过程如下
```
const arr = [8, 4, 2, 3, 1]
Insertion(arr)

i  j   0    1    2    3    4
       8    4    2    3    1
1  0   4,   8,   2,   3,   1
2  0   2,   4,   8,   3,   1
3  1   2,   3,   4,   8,   1
4  4   1,   2,   3,   4,   8

const arr = [8, 7, 6, 5, 4]
Insertion(arr)

i  j   0    1    2    3    4
       8    7    6    5    4
1  0   7,   8,   6,   5,   4
2  0   6,   7,   8,   5,   4
3  0   5,   6,   7,   8,   4
4  0   4,   5,   6,   7,   8
```
可以明显地看到，每次插入的时候，都会将待插入位置右边的元素往后移动。

#### 总结：

长度为N的集合，可以有如下集中情况。

在最理想的情况（集合已经是有序的），只需要N-1次比较，0次交换。

最坏的情况下（集合是逆序的），比较次数1+2+...+N-1=N^2/2，同时交换次数也是一样的1+2+...+N-1=N^2/2。

平均的情况下，只有一半的元素需要向右移动，因此比较次数是最坏情况下1/2，即比较次数是N^2/4，和N^2/4的交换次数。

因此插入排序的时间复杂度为O(N^2)

总体来说，插入排序还是会比选择排序快。

### 冒泡排序
这种排序会将元素像气泡一样，向前移动。

```javascript
const Bubble = (coll) => {
  const len = coll.length
  var swapped
  for(var i = 0; i < len - 1; i++) {
    swapped = false
    for(var j = 0; j < len - 1 - i; j++) {
      if(coll[j] > coll[j+1]) {
        exchange(coll, j, j+1)
        swapped ＝ true
      }
    }
    if(!swapped)
      return
  }
}
```
这种排序的过程如下
```
const arr = [8, 5, 1, 6, 3]
Bubble(arr)

i  j   0    1    2    3    4
       8    5    1    6    3
0  4   5,   1,   6,   3,   8
1  3   1,   5,   3,   6,   8
2  2   1,   3,   5,   6,   8
3  1   1,   3,   5,   6,   8

const arr = [8, 7, 6, 5, 4]
Bubble(arr)

i  j   0    1    2    3    4
       8    7    6    5    4
0  4   7,   6,   5,   4,   8
1  3   6,   5,   4,   7,   8
2  2   5,   4,   6,   7,   8
3  1   4,   5,   6,   7,   8
```
可以看到，第i次排序，都会将i+1个元素中最大的一个向右冒泡移动。

#### 总结：
上述冒泡的代码是经过改进后的，即我们加上了swapped来判断外0到len-1-i这多个元素是否已经是是排好顺序的元素，这样可以让我们避免去循环遍历它们。

这个改进后的冒泡，最好情况下（集合都是顺序的），只需要比较N-1次即可。

最坏情况下（集合是倒序的），需要1+2+...+N-1=N^2/2次的比较次数。

平均况下，需要N^2/4次的比较次数。

总的来说冒泡排序的时间复杂度为O(N^2)

### 稳定排序和非稳定排序
所谓的稳定和非稳定排序，就是排序前后，两个元素相对位置是否变化，如果没有变化则是稳定排序，反之则是非稳定排序。

如5,6（1）,1,4,3,6（2）这么一个序列：

如果排序后的序列是1,2,3,4,5,6（1），6（2）那我们则会说这次排序使用的算法是稳定排序算法。

如果排序后的序列是1,2,3,4,5,6（2），6（1）那我们则会说这次排序使用的算法是非稳定排序算法。

选择排序，插入排序，冒泡排序都是稳定排序算法。

快速排序，希尔排序都是非稳定排序算法。

未完待续...
