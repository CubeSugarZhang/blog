# 闭包
代码解释
```javascript
function foo() { 
  var a = 2;
  function bar() { 
    console.log(a)
  }
  return bar
}
var baz = foo()
baz() // 2 
```

foo执行结束后，正常来说变量就要被垃圾回收给回收掉，但是此处却没有。这便是闭包的功力

由于bar函数声明的位置的原因，导致foo内存作用域并没有被回收，而bar对这个作用域的引用就是闭包

## 一道经典的闭包面试题
```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(function () {
    console.log(i)
  }, i * 1000)
}
```
运行后，结果是每隔1s会打印出6，总共打印出5次

每隔1s，总共打印6次很好理解，因为我们循环从i=1到i=5，setTimeout总共运行了5次  
每次传入的i的参数（setTimeout的第二个参数）分别是1000、2000、...、5000

那为什么每次打印出来都是6？  
其实即使是setTimeout(..., 0)它也是打印出5次6。主要原因是setTimeout中指定的回调函数，都是在循环结束时运行的。  
循环结束时i的值是6，而由于闭包的原因，回调函数依然保持了对外部变量的引用，所以获取到的i便是6，也即打印出了6。  
换句话说，此处相当于创建了五个回调函数，但是完成的作用域只有一个，也即只有一个i，所以每个回调函数取到的i都是同一个对象。

那有什么方式可以让其每次都打印循环中i的值呢？  
其实我们只需要每次迭代中都产生一个闭包作用域即可，让每个闭包作用域中的i都是不同的。
```javascript
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function () {
      console.log(j)
    }, j * 1000)
  })(i)
}
```
此时回调函数调用的j变量，来自外层作用域。该外层作用域中的j，是每次循环传入进来的。这也使得每次循环都会产生一个新的作用域。  
而每次产生的作用域不会被释放掉，也是因为内存回调函数造成的闭包的原因。

既然我们是想让每次循环产生的作用域都是独特的，那便还可以这样使用
```javascript
for (let i = 1; i <= 5; i++) {
  setTimeout(function () {
    console.log(i)
  }, i * 1000)
}
```
与最终的代码的变化只是`var`变成了`let`，具体let的用法可以参考 [let和const命令](http://es6.ruanyifeng.com/#docs/let)

## 闭包的作用
通过使用闭包，我们可以访问局部变量，同时让这些变量不被释放。

我们可以通过闭包实现数据私有化，即外部无法直接使用局部变量
```javascript
function f1(){
  var n=999
　nAdd= function(){
    n+=1
  }
　function f2(){
    alert(n)
　}
  return f2
}
var result=f1()
result() // 999
nAdd()
result() // 1000
```

外部无法直接获取变量，进而修改变量，起到了保护变量的作用。只能通过调用内存函数修改和获取变量

## 闭包和内存泄漏
很多人认为闭包中的变量没有被释放，便夸大其词去证明使用闭包不好，会造成内存泄漏。

我个人理解是，通过闭包，让一些局部变量不用被反复创建，这种方式和你定义为全局变量有相似之处。

但是因为闭包中引用的外层变量过多，然后又没有释放变量，最终造成内存泄漏的问题，这只能说明一个问题，你代码写得不好罢了。

参考几篇文章：
1. [关于js闭包是否真的会造成内存泄漏？](https://www.zhihu.com/question/31078912)
